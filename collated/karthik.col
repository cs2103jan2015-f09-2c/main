//@author: karthik



	/**
	 * origin: D:\Code\Planner4Life (Debug)\Task\Task.cpp
	 */

//Function takes in user input and stores the task details
void Task::addDetails(string details){
	int noOfDelimiters;

	processImportance(details);

	noOfDelimiters = count(details.begin(), details.end(), ';');
	switch (noOfDelimiters){
	case 0:
		process_NoDelimiter(details);
		break;
	case 1:
		process_OneDelimiter(details);
		break;
	case 2:
		process_TwoDelimiter(details);
		break;
	default:
		throw exception(ERROR_MESSAGE_INVALID_INPUT);
	
//	 LogData->addLog(UPDATE, ADD_DETAILS_SUCCESSFUL);
	}
}

//For the case when there is only description and no other information fields; stores the task details
void Task::process_NoDelimiter(string details) {
	_description = details;
}

//For the case when there is description and one other info field (either date or time) separated by a delimiter; stores the task details
void Task::process_OneDelimiter(string details) {
	processDescription(details);
	try{
		if (details.find(" date") != string::npos){
			processDate(details);
		}
		else if (details.find(" time") != string::npos){
			processTime(details);
		}
		else {
			throw exception(ERROR_MESSAGE_INVALID_INPUT);
		}
	}
	catch (exception const& error){
		throw;
	}
}

//For the case when there is description and 2 other information fields (date and time) separated by delimiters; stores task details
void Task::process_TwoDelimiter(string details) {
	int semicolonPos;
	string durationInfo, dateInfo, timeInfo;

	processDescription(details);
	semicolonPos = details.find(';');
	durationInfo = details.substr(0, semicolonPos);

	try{
		if (durationInfo.find(" date") != string::npos){
			dateInfo = details.substr(0, semicolonPos);
		}
		else if (durationInfo.find(" time") != string::npos){
			timeInfo = details.substr(0, semicolonPos);
		}
		else {
			throw exception(ERROR_MESSAGE_INVALID_INPUT);
		}
	}
	catch (exception const& error){
		throw;
	}

	semicolonPos++;
	if (timeInfo.empty()){
		timeInfo = details.substr(semicolonPos, details.size() - semicolonPos);
	}
	else if (dateInfo.empty()){
		dateInfo = details.substr(semicolonPos, details.size() - semicolonPos);
	}
	processDate(dateInfo);
	processTime(timeInfo);
}

//Checks if task is important and returns the remainder of user input
void Task::processImportance(string& details){
	int hashPosition;
	hashPosition = details.find("#");
	if (hashPosition != string::npos){
		_isImpt = true;
		details = details.substr(0, hashPosition);
	}
}

//stores description into task object and returns the remainder of user input
void Task::processDescription(string& details){
	int descriptionEnd;

	descriptionEnd = details.find_first_of(";");
	_description = details.substr(0, descriptionEnd);
	descriptionEnd++;
	details = details.substr(descriptionEnd, details.size() - descriptionEnd);				//cut out the description part to be left with the date and/or time part
}

	// End of segment: D:\Code\Planner4Life (Debug)\Task\Task.cpp





	/**
	 * origin: D:\Code\Planner4Life (Debug)\Task\Task.cpp
	 */

//Takes in date related information in a string and stores into the respective variables in Task object
void Task::processDate(string dateInfo){
	string keyword, startDate, endDate, separator;
	int separatorPos;
	istringstream in(dateInfo);

	separatorPos = dateInfo.find("to");			// locate the word to in string
	if (separatorPos != string::npos){
		in >> keyword;
		in >> startDate;
		in >> separator;
		in >> endDate;

		processTwoDates(startDate, endDate);
	}
	else{
		in >> keyword;
		in >> endDate;

		processOneDate(endDate);
	}
}

//Splits the start date string into individual components and stores them in the relevant variables
void Task::storeStartDate(string dateStart){
	int day, month, year;
	splitDate(dateStart, day, month, year);

	_dateStart.day = day;
	_dateStart.month = month;
	_dateStart.year = year;
}

//Splits the end date string into individual components and stores them in the relevant variables
void Task::storeEndDate(string dateEnd){
	int day, month, year;
	splitDate(dateEnd, day, month, year);

	_dateEnd.day = day;
	_dateEnd.month = month;
	_dateEnd.year = year;
}

//Takes in time related information in a string and stores into the respective variables in Task object
void Task::processTime(string timeInfo){

	int separatorPos;
	string keyword, timeStart, timeEnd, separator;

	istringstream in(timeInfo);
	separatorPos = timeInfo.find("to");			// locate the word to in string

	if (separatorPos != string::npos){
		in >> keyword;
		in >> timeStart;
		in >> separator;
		in >> timeEnd;

		try{
			if (areValidTimes(timeStart, timeEnd)){
				storeStartTime(timeStart);
				storeEndTime(timeEnd);
				_numOfTimes = 2;
			}
			else {
				throw exception(ERROR_MESSAGE_INVALID_INPUT);
			}
		}
		catch (exception const& error){
			throw;
		}
	}
	else{
		in >> keyword;
		in >> timeStart;

		try{
			if (areValidTimes(timeStart, timeStart)){
				storeStartTime(timeStart);
				_numOfTimes = 1;
			}
			else {
				throw exception(ERROR_MESSAGE_INVALID_INPUT);
			}
		}
		catch (exception const& error){
			throw;
		}
	}
}

	// End of segment: D:\Code\Planner4Life (Debug)\Task\Task.cpp





	/**
	 * origin: D:\Code\Planner4Life (Debug)\Task\Task.cpp
	 */

//Stores a unique ID number that is created by the Planner class
void Task::storeIdNumber(int num){
	_idNumber = num;
}

//Marks a particular task as done
void Task::markIsDoneAsTrue(){
	_isDone = true;
}

/************************************************************************************************

Task Information Getter Functions

************************************************************************************************/

string Task::getDescription(){
	return _description;
}

int Task::getTimeStart(){
	return _timeStart;
}

int Task::getTimeEnd(){
	return _timeEnd;
}

taskDate Task::getDateStart(){
	return _dateStart;
}

taskDate Task::getDateEnd(){
	return _dateEnd;
}

bool Task::getImportance(){
	return _isImpt;
}

int Task::getIdNumber(){
	return _idNumber;
}

int Task::getNumOfDates(){
	return _numOfDates;
}

int Task::getNumOfTimes(){
	return _numOfTimes;
}

list<Task> Task::getRecurringTasks(){
	return _recurringTasks;
}
	// End of segment: D:\Code\Planner4Life (Debug)\Task\Task.cpp





	/**
	 * origin: D:\Code\Planner4Life (Debug)\TaskUnitTest\TaskPositiveUnitTest.cpp
	 */

		TEST_METHOD(testSearchTarget_targetPresent){
			Task testTask;
			string searchTarget = "meeting";

			testTask.addDetails("Meeting with Prof; date 270315; time 1400");

			Assert::IsTrue(testTask.isSearchTargetPresent(searchTarget));
		}

		TEST_METHOD(testSearchTarget_targetNotPresent){
			Task testTask;
			string searchTarget = "class";

			testTask.addDetails("Meeting with Prof; date 270315; time 1400");

			Assert::IsFalse(testTask.isSearchTargetPresent(searchTarget));
		}

		/************************************************************************************************

		Recur Unit Tests

		************************************************************************************************/
		TEST_METHOD(testRecurTask_numOfTimesRecurred){
			Task testTask;
			int numOfTimesRecurred;

			testTask.recurTask("daily 5; Project meeting; date 250415; time 1500");
			numOfTimesRecurred = testTask.getRecurringTasks().size();

			Assert::AreEqual(5, numOfTimesRecurred);
		}

		//To test if the recurring tasks dates are updated. Recurring 5 times is chosen arbitrarily.
		//Date is specifically chosen to spill from one month to another for daily, one month to another for weekly, 
		//one year to another for monthly, to test the date changing logic
		//***** Daily Tests ******//
		TEST_METHOD(testRecurTask_Daily_RecurredFiveTimes_Date_Day){ 
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskDay;
			list<Task> taskList;

			testTask.recurTask("daily 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskDay = (*taskIter).getDateEnd().day;
			Assert::AreEqual(2, fifthRecurredTaskDay);
		}

		TEST_METHOD(testRecurTask_Daily_RecurredFiveTimes_Date_Month){
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskMonth;
			list<Task> taskList;

			testTask.recurTask("daily 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskMonth = (*taskIter).getDateEnd().month;
			Assert::AreEqual(12, fifthRecurredTaskMonth);
		}
		
		TEST_METHOD(testRecurTask_Daily_RecurredFiveTimes_Date_Year){
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskYear;
			list<Task> taskList;

			testTask.recurTask("daily 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskYear = (*taskIter).getDateEnd().year;
			Assert::AreEqual(15, fifthRecurredTaskYear);
		}

		//***** Monthly Tests ******//
		TEST_METHOD(testRecurTask_Monthly_RecurredFiveTimes_Date_Day){
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskDay;
			list<Task> taskList;

			testTask.recurTask("monthly 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskDay = (*taskIter).getDateEnd().day;
			Assert::AreEqual(28, fifthRecurredTaskDay);
		}

		TEST_METHOD(testRecurTask_Monthly_RecurredFiveTimes_Date_Month){
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskMonth;
			list<Task> taskList;

			testTask.recurTask("monthly 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskMonth = (*taskIter).getDateEnd().month;
			Assert::AreEqual(3, fifthRecurredTaskMonth);
		}

		TEST_METHOD(testRecurTask_Monthly_RecurredFiveTimes_Date_Year){
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskYear;
			list<Task> taskList;

			testTask.recurTask("monthly 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskYear = (*taskIter).getDateEnd().year;
			Assert::AreEqual(16, fifthRecurredTaskYear);
		}

		//***** Weekly Tests ******//
		TEST_METHOD(testRecurTask_Weekly_RecurredFiveTimes_Date_Day){
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskDay;
			list<Task> taskList;

			testTask.recurTask("weekly 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskDay = (*taskIter).getDateEnd().day;
			Assert::AreEqual(26, fifthRecurredTaskDay);
		}

		TEST_METHOD(testRecurTask_Weekly_RecurredFiveTimes_Date_Month){
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskMonth;
			list<Task> taskList;

			testTask.recurTask("weekly 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskMonth = (*taskIter).getDateEnd().month;
			Assert::AreEqual(12, fifthRecurredTaskMonth);
		}

		TEST_METHOD(testRecurTask_Weekly_RecurredFiveTimes_Date_Year){
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskYear;
			list<Task> taskList;

			testTask.recurTask("weekly 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskYear = (*taskIter).getDateEnd().year;
			Assert::AreEqual(15, fifthRecurredTaskYear);
		}

		//***** Yearly Tests ******//
		TEST_METHOD(testRecurTask_Yearly_RecurredFiveTimes_Date_Day){
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskDay;
			list<Task> taskList;

			testTask.recurTask("yearly 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskDay = (*taskIter).getDateEnd().day;
			Assert::AreEqual(28, fifthRecurredTaskDay);
		}

		TEST_METHOD(testRecurTask_Yearly_RecurredFiveTimes_Date_Month){
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskMonth;
			list<Task> taskList;

			testTask.recurTask("yearly 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskMonth = (*taskIter).getDateEnd().month;
			Assert::AreEqual(11, fifthRecurredTaskMonth);
		}

		TEST_METHOD(testRecurTask_Yearly_RecurredFiveTimes_Date_Year){
			Task testTask;
			taskDate updatedDateOfLastEntry;
			int fifthRecurredTaskYear;
			list<Task> taskList;

			testTask.recurTask("yearly 5; Project meeting; date 281115; time 1500");
			list<Task>::iterator taskIter;
			taskList = testTask.getRecurringTasks();
			taskIter = taskList.end();
			taskIter--;
			fifthRecurredTaskYear = (*taskIter).getDateEnd().year;
			Assert::AreEqual(19, fifthRecurredTaskYear);
		}

	};
}

	// End of segment: D:\Code\Planner4Life (Debug)\TaskUnitTest\TaskPositiveUnitTest.cpp





	/**
	 * origin: D:\Code\Planner4Life(Release)\Task\Task.cpp
	 */

//Function takes in user input and stores the task details
void Task::addDetails(string details){
	int noOfDelimiters;

	processImportance(details);

	noOfDelimiters = count(details.begin(), details.end(), ';');
	switch (noOfDelimiters){
	case 0:
		process_NoDelimiter(details);
		break;
	case 1:
		process_OneDelimiter(details);
		break;
	case 2:
		process_TwoDelimiter(details);
		break;
	default:
		throw exception(ERROR_MESSAGE_INVALID_INPUT);
	}
}

//For the case when there is only description and no other information fields; stores the task details
void Task::process_NoDelimiter(string details) {
	LogData->addLog(UPDATE, ADD_DETAILS_CASE_0_CALLED);
	_description = details;
	LogData->addLog(UPDATE, ADD_DETAILS_CASE_0_SUCCESSFUL);
}

//For the case when there is description and one other info field (either date or time) separated by a delimiter; stores the task details
void Task::process_OneDelimiter(string details) {
	LogData->addLog(UPDATE, ADD_DETAILS_CASE_1_CALLED);
	processDescription(details);
	try{
		if (details.find(" date") != string::npos){
			processDate(details);
		}
		else if (details.find(" time") != string::npos){
			processTime(details);
		}
		else {
			throw exception(ERROR_MESSAGE_INVALID_INPUT);
		}
	}
	catch (exception const& error){
		throw;
	}
	LogData->addLog(UPDATE, ADD_DETAILS_CASE_1_SUCCESSFUL);
}

//For the case when there is description and 2 other information fields (date and time) separated by delimiters; stores task details
void Task::process_TwoDelimiter(string details) {
	int semicolonPos;
	string durationInfo, dateInfo, timeInfo;
	LogData->addLog(UPDATE, ADD_DETAILS_CASE_2_CALLED);

	processDescription(details);
	semicolonPos = details.find(';');
	durationInfo = details.substr(0, semicolonPos);

	try{
		if (durationInfo.find(" date") != string::npos){
			dateInfo = details.substr(0, semicolonPos);
		}
		else if (durationInfo.find(" time") != string::npos){
			timeInfo = details.substr(0, semicolonPos);
		}
		else {
			throw exception(ERROR_MESSAGE_INVALID_INPUT);
		}
	}
	catch (exception const& error){
		throw;
	}

	semicolonPos++;
	if (timeInfo.empty()){
		timeInfo = details.substr(semicolonPos, details.size() - semicolonPos);
	}
	else if (dateInfo.empty()){
		dateInfo = details.substr(semicolonPos, details.size() - semicolonPos);
	}
	processDate(dateInfo);
	processTime(timeInfo);
	LogData->addLog(UPDATE, ADD_DETAILS_CASE_2_SUCCESSFUL);
}

//Checks if task is important and returns the remainder of user input
void Task::processImportance(string& details){
	int hashPosition;
	hashPosition = details.find("#");
	if (hashPosition != string::npos){
		_isImpt = true;
		details = details.substr(0, hashPosition);
	}
}

//stores description into task object and returns the remainder of user input
void Task::processDescription(string& details){
	int descriptionEnd;

	descriptionEnd = details.find_first_of(";");
	_description = details.substr(0, descriptionEnd);
	descriptionEnd++;
	details = details.substr(descriptionEnd, details.size() - descriptionEnd);				//cut out the description part to be left with the date and/or time part
	LogData->addLog(UPDATE, ADD_DETAILS_DESCRIPTION_SUCCESSFUL);
}

	// End of segment: D:\Code\Planner4Life(Release)\Task\Task.cpp





	/**
	 * origin: D:\Code\Planner4Life(Release)\Task\Task.cpp
	 */

//Takes in date related information in a string and stores into the respective variables in Task object
void Task::processDate(string dateInfo){
	string keyword, startDate, endDate, separator;
	int separatorPos;
	istringstream in(dateInfo);

	separatorPos = dateInfo.find("to");			// locate the word to in string
	if (separatorPos != string::npos){
		in >> keyword;
		in >> startDate;
		in >> separator;
		in >> endDate;

		processTwoDates(startDate, endDate);
	}
	else{
		in >> keyword;
		in >> endDate;

		processOneDate(endDate);
	}
}

//Splits the start date string into individual components and stores them in the relevant variables
void Task::storeStartDate(string dateStart){
	int day, month, year;
	splitDate(dateStart, day, month, year);

	_dateStart.day = day;
	_dateStart.month = month;
	_dateStart.year = year;
}

//Splits the end date string into individual components and stores them in the relevant variables
void Task::storeEndDate(string dateEnd){
	int day, month, year;
	splitDate(dateEnd, day, month, year);

	_dateEnd.day = day;
	_dateEnd.month = month;
	_dateEnd.year = year;
}

//Takes in time related information in a string and stores into the respective variables in Task object
void Task::processTime(string timeInfo){

	int separatorPos;
	string keyword, timeStart, timeEnd, separator;

	istringstream in(timeInfo);
	separatorPos = timeInfo.find("to");			// locate the word to in string

	if (separatorPos != string::npos){
		in >> keyword;
		in >> timeStart;
		in >> separator;
		in >> timeEnd;

		try{
			if (areValidTimes(timeStart, timeEnd)){
				storeStartTime(timeStart);
				storeEndTime(timeEnd);
				_numOfTimes = 2;
				LogData->addLog(UPDATE, ADD_DETAILS_TIME_SUCCESSFUL);
			}
			else {
				LogData->addLog(UPDATE, ADD_DETAILS_TIME_INVALID);
				throw exception(ERROR_MESSAGE_INVALID_INPUT);
			}
		}
		catch (exception const& error){
			throw;
		}
	}
	else{
		in >> keyword;
		in >> timeStart;

		try{
			if (areValidTimes(timeStart, timeStart)){
				storeStartTime(timeStart);
				_numOfTimes = 1;
				LogData->addLog(UPDATE, ADD_DETAILS_TIME_SUCCESSFUL);
			}
			else {
				LogData->addLog(UPDATE, ADD_DETAILS_TIME_INVALID);
				throw exception(ERROR_MESSAGE_INVALID_INPUT);
			}
		}
		catch (exception const& error){
			throw;
		}
	}
}

	// End of segment: D:\Code\Planner4Life(Release)\Task\Task.cpp





	/**
	 * origin: D:\Code\Planner4Life(Release)\Task\Task.cpp
	 */

//Stores a unique ID number that is created by the Planner class
void Task::storeIdNumber(int num){
	_idNumber = num;
}

//Marks a particular task as done
void Task::markIsDoneAsTrue(){
	_isDone = true;
}

/************************************************************************************************

Task Information Getter Functions

************************************************************************************************/

string Task::getDescription(){
	return _description;
}

int Task::getTimeStart(){
	return _timeStart;
}

int Task::getTimeEnd(){
	return _timeEnd;
}

taskDate Task::getDateStart(){
	return _dateStart;
}

taskDate Task::getDateEnd(){
	return _dateEnd;
}

bool Task::getImportance(){
	return _isImpt;
}

int Task::getIdNumber(){
	return _idNumber;
}

int Task::getNumOfDates(){
	return _numOfDates;
}

int Task::getNumOfTimes(){
	return _numOfTimes;
}

list<Task> Task::getRecurringTasks(){
	return _recurringTasks;
}
	// End of segment: D:\Code\Planner4Life(Release)\Task\Task.cpp





	/**
	 * origin: D:\Code\Task.cpp
	 */

//Function takes in user input and stores the task details
void Task::addDetails(string details){
	int noOfDelimiters;

	processImportance(details);

	noOfDelimiters = count(details.begin(), details.end(), ';');
	switch (noOfDelimiters){
	case 0:
		process_NoDelimiter(details);
		break;
	case 1:
		process_OneDelimiter(details);
		break;
	case 2:
		process_TwoDelimiter(details);
		break;
	default:
		throw exception(ERROR_MESSAGE_INVALID_INPUT);
	
//	 LogData->addLog(UPDATE, ADD_DETAILS_SUCCESSFUL);
	}
}

//For the case when there is only description and no other information fields; stores the task details
void Task::process_NoDelimiter(string details) {
	_description = details;
}

//For the case when there is description and one other info field (either date or time) separated by a delimiter; stores the task details
void Task::process_OneDelimiter(string details) {
	processDescription(details);
	try{
		if (details.find(" date") != string::npos){
			processDate(details);
		}
		else if (details.find(" time") != string::npos){
			processTime(details);
		}
		else {
			throw exception(ERROR_MESSAGE_INVALID_INPUT);
		}
	}
	catch (exception const& error){
		throw;
	}
}

//For the case when there is description and 2 other information fields (date and time) separated by delimiters; stores task details
void Task::process_TwoDelimiter(string details) {
	int semicolonPos;
	string durationInfo, dateInfo, timeInfo;

	processDescription(details);
	semicolonPos = details.find(';');
	durationInfo = details.substr(0, semicolonPos);

	try{
		if (durationInfo.find(" date") != string::npos){
			dateInfo = details.substr(0, semicolonPos);
		}
		else if (durationInfo.find(" time") != string::npos){
			timeInfo = details.substr(0, semicolonPos);
		}
		else {
			throw exception(ERROR_MESSAGE_INVALID_INPUT);
		}
	}
	catch (exception const& error){
		throw;
	}

	semicolonPos++;
	if (timeInfo.empty()){
		timeInfo = details.substr(semicolonPos, details.size() - semicolonPos);
	}
	else if (dateInfo.empty()){
		dateInfo = details.substr(semicolonPos, details.size() - semicolonPos);
	}
	processDate(dateInfo);
	processTime(timeInfo);
}

//Checks if task is important and returns the remainder of user input
void Task::processImportance(string& details){
	int hashPosition;
	hashPosition = details.find("#");
	if (hashPosition != string::npos){
		_isImpt = true;
		details = details.substr(0, hashPosition);
	}
}

//stores description into task object and returns the remainder of user input
void Task::processDescription(string& details){
	int descriptionEnd;

	descriptionEnd = details.find_first_of(";");
	_description = details.substr(0, descriptionEnd);
	descriptionEnd++;
	details = details.substr(descriptionEnd, details.size() - descriptionEnd);				//cut out the description part to be left with the date and/or time part
}

	// End of segment: D:\Code\Task.cpp





	/**
	 * origin: D:\Code\Task.cpp
	 */

//Takes in date related information in a string and stores into the respective variables in Task object
void Task::processDate(string dateInfo){
	string keyword, startDate, endDate, separator;
	int separatorPos;
	istringstream in(dateInfo);

	separatorPos = dateInfo.find("to");			// locate the word to in string
	if (separatorPos != string::npos){
		in >> keyword;
		in >> startDate;
		in >> separator;
		in >> endDate;

		processTwoDates(startDate, endDate);
	}
	else{
		in >> keyword;
		in >> endDate;

		processOneDate(endDate);
	}
}

//Splits the start date string into individual components and stores them in the relevant variables
void Task::storeStartDate(string dateStart){
	int day, month, year;
	splitDate(dateStart, day, month, year);

	_dateStart.day = day;
	_dateStart.month = month;
	_dateStart.year = year;
}

//Splits the end date string into individual components and stores them in the relevant variables
void Task::storeEndDate(string dateEnd){
	int day, month, year;
	splitDate(dateEnd, day, month, year);

	_dateEnd.day = day;
	_dateEnd.month = month;
	_dateEnd.year = year;
}

//Takes in time related information in a string and stores into the respective variables in Task object
void Task::processTime(string timeInfo){

	int separatorPos;
	string keyword, timeStart, timeEnd, separator;

	istringstream in(timeInfo);
	separatorPos = timeInfo.find("to");			// locate the word to in string

	if (separatorPos != string::npos){
		in >> keyword;
		in >> timeStart;
		in >> separator;
		in >> timeEnd;

		try{
			if (areValidTimes(timeStart, timeEnd)){
				storeStartTime(timeStart);
				storeEndTime(timeEnd);
				_numOfTimes = 2;
			}
			else {
				throw exception(ERROR_MESSAGE_INVALID_INPUT);
			}
		}
		catch (exception const& error){
			throw;
		}
	}
	else{
		in >> keyword;
		in >> timeStart;

		try{
			if (areValidTimes(timeStart, timeStart)){
				storeStartTime(timeStart);
				_numOfTimes = 1;
			}
			else {
				throw exception(ERROR_MESSAGE_INVALID_INPUT);
			}
		}
		catch (exception const& error){
			throw;
		}
	}
}

	// End of segment: D:\Code\Task.cpp





	/**
	 * origin: D:\Code\Task.cpp
	 */

//Stores a unique ID number that is created by the Planner class
void Task::storeIdNumber(int num){
	_idNumber = num;
}

//Marks a particular task as done
void Task::markIsDoneAsTrue(){
	_isDone = true;
}

/************************************************************************************************

Task Information Getter Functions

************************************************************************************************/

string Task::getDescription(){
	return _description;
}

int Task::getTimeStart(){
	return _timeStart;
}

int Task::getTimeEnd(){
	return _timeEnd;
}

taskDate Task::getDateStart(){
	return _dateStart;
}

taskDate Task::getDateEnd(){
	return _dateEnd;
}

bool Task::getImportance(){
	return _isImpt;
}

int Task::getIdNumber(){
	return _idNumber;
}

int Task::getNumOfDates(){
	return _numOfDates;
}

int Task::getNumOfTimes(){
	return _numOfTimes;
}

list<Task> Task::getRecurringTasks(){
	return _recurringTasks;
}
	// End of segment: D:\Code\Task.cpp





