//@author: a0111314a



	/**
	 * origin: D:\Code\Planner4Life (Debug)\GUI\Planner4LifeGUI.h
	 */


	private:
		//UI operation elements
		Logic* _plannerLogic;
		String^ _currentView;
		bool _clearTrigger;

		//GUI elements
		System::Windows::Forms::TextBox^  displayWindow;
		System::Windows::Forms::TextBox^  userInput;
		System::Windows::Forms::Button^  missedButton;
		System::Windows::Forms::Button^  upcomingButton;
		System::Windows::Forms::Button^  homeButton;
		System::Windows::Forms::Label^  status;


		//constant strings
		String^ VIEWTYPE_HOME = "Home";
		String^ VIEWTYPE_UPCOMING = "Upcoming";
		String^ VIEWTYPE_MISSED = "Missed";
		String^ VIEWTYPE_HELP = "Help";
		String^ VIEWTYPE_ALL = "All";
		String^ VIEWTYPE_DONE = "Done";
		String^ VIEWTYPE_SEARCH = "Search";

		String^ COMMAND_HOME = "home";
		String^ COMMAND_UPCOMING = "upcoming";
		String^ COMMAND_MISSED = "missed";
		String^ COMMAND_HELP = "help";
		String^ COMMAND_ALL = "all";
		String^ COMMAND_SHOW_DONE = "show done";
		String^ COMMAND_SEARCH = "search";
		String^ COMMAND_EXIT = "exit";
		String^ COMMAND_CLEAR = "clear";
		String^ COMMAND_Y = "Y";
		String^ COMMAND_N = "N";
		String^ COMMAND_y = "y";
		String^ COMMAND_n = "n";
		String^ STATUS_CLEAR_PROMPT = "Are you sure you want to clear? Enter <Y> to confirm or <N> to cancel";

		/// Required designer variable.
		System::ComponentModel::Container ^components;

	public:
		GUI(void){
			InitializeComponent();
			//Add the constructor code here
			_plannerLogic = new Logic;
			_currentView = VIEWTYPE_HOME;
			_clearTrigger = false;
		}

	protected:
		/// Clean up any resources being used.
		~GUI(){
			if (components)	{
				delete components;
				delete _plannerLogic;
				delete _currentView;
			}
		}

	// End of segment: D:\Code\Planner4Life (Debug)\GUI\Planner4LifeGUI.h





	/**
	 * origin: D:\Code\Planner4Life (Debug)\GUI\Planner4LifeGUI.h
	 */


		/************************************************************************************************

		Initialization

		************************************************************************************************/
		//Function to initialize beginning state of Planner4Life to home screen with loadFile prompt
	private: System::Void GUI_Load(System::Object^  sender, System::EventArgs^  e) {
		string strStatus = _plannerLogic->displayStatus();

		executeHome(sender, e);
		status->Text = gcnew String(strStatus.c_str());
		missedAlertCheck();
	}

			 /************************************************************************************************

			 GUI control functions

			 ************************************************************************************************/

			 //Handler function that takes in user input and directs it to the different Planner operations
	private: System::Void userInput_Process(System::Object^  sender, System::Windows::Forms::KeyEventArgs^  e) {
		string searchCheck, clearCommand;
		String^ input = userInput->Text;

		searchCheck = msclr::interop::marshal_as<std::string>(input);

		if (e->KeyCode == Keys::Enter) {
			e->Handled = true;

			if (input == COMMAND_HOME) {
				executeHome(sender, e);
			}
			else if (input == COMMAND_MISSED) {
				executeMissed(sender, e);
			}
			else if (input == COMMAND_UPCOMING) {
				executeUpcoming(sender, e);
			}
			else if (input == COMMAND_HELP) {
				executeHelp();
			}
			else if (input == COMMAND_SHOW_DONE) {
				executeDone();
			}
			else if (input == COMMAND_ALL) {
				executeAll();
			}
			else if (input == COMMAND_EXIT) {
				executeExit();
			}
			else if (input == COMMAND_CLEAR) {
				activateCleartrigger();
			}
			else if ((input == COMMAND_Y || input == COMMAND_N || input == COMMAND_y || input == COMMAND_n) && _clearTrigger == true) {
				executeClear();
			}
			else if (searchCheck.find("search") != string::npos) {
				executeSearch();
			}
			else {
				processInput(input, _currentView);
			}

			userInput->Text = "";
		}
	}

			 // Parent function to take in all other user input, pass to Logic and return display and user prompt. All user input goes through 
			 // this function, but some specific commads (ie search, show done) require setup of UI state before processing. Their functions 
			 // are listed below
	private: System::Void processInput(String^ managedInput, String^ managedView) {
		String^ StrDisplay;
		String^ StrStatus;
		string unmanagedInput = msclr::interop::marshal_as<std::string>(managedInput);
		string unmanagedView = msclr::interop::marshal_as<std::string>(managedView);

		_plannerLogic->processUserInput(unmanagedInput, unmanagedView);
		missedAlertCheck();

		string strDisplay = _plannerLogic->displayContent();
		string strStatus = _plannerLogic->displayStatus();

		StrDisplay = gcnew String(strDisplay.c_str());
		displayWindow->Text = StrDisplay;
		StrStatus = gcnew String(strStatus.c_str());
		status->Text = StrStatus;
	}

			 //Function to execute 'help' command'
	private: System::Void executeHelp() {
		_currentView = VIEWTYPE_HELP;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 //Function to execute 'show done' command
	private: System::Void executeDone() {
		_currentView = VIEWTYPE_DONE;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 // Function to execute 'all' command
	private: System::Void executeAll() {
		_currentView = VIEWTYPE_ALL;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 //Function to execute 'exit' command
	private: System::Void executeExit() {
		Application::Exit();
	}

			 //Function to set up preliminary action for 'clear' operation - warns user and sets the UI state to allow 'clear' command
	private: System::Void activateCleartrigger() {
		status->Text = STATUS_CLEAR_PROMPT;
		_clearTrigger = true;
	}

			 //Function to execute 'clear' operation. Thereafter resets UI state to disallow immediate 'clear' on command. 
	private: System::Void executeClear() {
		_currentView = VIEWTYPE_HOME;
		switchView(_currentView);

		String^ StrDecision = "clear ";
		StrDecision = StrDecision + userInput->Text;

		processInput(StrDecision, _currentView);
		_clearTrigger = false;
	}

			 //Function to execute 'search' operation
	private: System::Void executeSearch() {
		_currentView = VIEWTYPE_SEARCH;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 /************************************************************************************************

			 GUI view functions

			 ************************************************************************************************/

			 //Function to control the colour of buttons depending on the view type. Views that are not Home, Upcoming or Missed
			 // are not specially highlighted.
	private: System::Void colourSwitch(String^ _currentView) {
		if (_currentView == VIEWTYPE_HOME) {
			homeButton->BackColor = Color::LightSkyBlue;
			missedButton->BackColor = Color::SteelBlue;
			upcomingButton->BackColor = Color::SteelBlue;
		}
		else if (_currentView == VIEWTYPE_UPCOMING) {
			upcomingButton->BackColor = Color::LightSkyBlue;
			missedButton->BackColor = Color::SteelBlue;
			homeButton->BackColor = Color::SteelBlue;
		}
		else if (_currentView == VIEWTYPE_MISSED) {
			missedButton->BackColor = Color::LightSkyBlue;
			upcomingButton->BackColor = Color::SteelBlue;
			homeButton->BackColor = Color::SteelBlue;
		}
		else {
			missedButton->BackColor = Color::SteelBlue;
			upcomingButton->BackColor = Color::SteelBlue;
			homeButton->BackColor = Color::SteelBlue;
		}
	}

			 //Function to check if there are any missed tasks. If there are, "Missed" button text becomes red to alert user
	private: System::Void missedAlertCheck(){
		bool areMissedTasks = _plannerLogic->checkMissedStatus();

		if (areMissedTasks){
			missedButton->ForeColor = Color::IndianRed;
		}
		else{
			missedButton->ForeColor = SystemColors::ControlText;
		}
	}

			 //Function to switch the view type of the GUI between Home, Upcoming and Missed.
	private: System::Void switchView(String^ viewType) {
		string unmanagedView = msclr::interop::marshal_as<std::string>(viewType);

		_plannerLogic->updateDisplay(unmanagedView);

		string strDisplay = _plannerLogic->displayContent();
		displayWindow->Text = gcnew String(strDisplay.c_str());
		colourSwitch(_currentView);
	}

			 //Function to execute view change to Home view
	private: System::Void executeHome(System::Object^  sender, System::EventArgs^  e) {
		_currentView = VIEWTYPE_HOME;
		switchView(_currentView);
		status->Text = VIEWTYPE_HOME;
	}

			 //Function to execute view change to Upcoming view
	private: System::Void executeUpcoming(System::Object^  sender, System::EventArgs^  e) {
		_currentView = VIEWTYPE_UPCOMING;
		switchView(_currentView);
		status->Text = VIEWTYPE_UPCOMING;
	}

			 //Function to execute view change to Missed view
	private: System::Void executeMissed(System::Object^  sender, System::EventArgs^  e) {
		_currentView = VIEWTYPE_MISSED;
		switchView(_currentView);
		status->Text = VIEWTYPE_MISSED;
	}
	};
}
	// End of segment: D:\Code\Planner4Life (Debug)\GUI\Planner4LifeGUI.h





	/**
	 * origin: D:\Code\Planner4Life(Release)\GUI\Planner4LifeGUI.h
	 */


	private:
		//UI operation elements
		Logic* _plannerLogic;
		String^ _currentView;
		bool _clearTrigger;

		//GUI elements
		System::Windows::Forms::TextBox^  displayWindow;
		System::Windows::Forms::TextBox^  userInput;
		System::Windows::Forms::Button^  missedButton;
		System::Windows::Forms::Button^  upcomingButton;
		System::Windows::Forms::Button^  homeButton;
		System::Windows::Forms::Label^  status;


		//constant strings
		String^ VIEWTYPE_HOME = "Home";
		String^ VIEWTYPE_UPCOMING = "Upcoming";
		String^ VIEWTYPE_MISSED = "Missed";
		String^ VIEWTYPE_HELP = "Help";
		String^ VIEWTYPE_ALL = "All";
		String^ VIEWTYPE_DONE = "Done";
		String^ VIEWTYPE_SEARCH = "Search";

		String^ COMMAND_HOME = "home";
		String^ COMMAND_UPCOMING = "upcoming";
		String^ COMMAND_MISSED = "missed";
		String^ COMMAND_HELP = "help";
		String^ COMMAND_ALL = "all";
		String^ COMMAND_SHOW_DONE = "show done";
		String^ COMMAND_SEARCH = "search";
		String^ COMMAND_EXIT = "exit";
		String^ COMMAND_CLEAR = "clear";
		String^ COMMAND_Y = "Y";
		String^ COMMAND_N = "N";
		String^ COMMAND_y = "y";
		String^ COMMAND_n = "n";
		String^ STATUS_CLEAR_PROMPT = "Are you sure you want to clear? Enter <Y> to confirm or <N> to cancel";

		/// Required designer variable.
		System::ComponentModel::Container ^components;

	public:
		GUI(void){
			InitializeComponent();
			//Add the constructor code here
			_plannerLogic = new Logic;
			_currentView = VIEWTYPE_HOME;
			_clearTrigger = false;
		}

	protected:
		/// Clean up any resources being used.
		~GUI(){
			if (components)	{
				delete components;
				delete _plannerLogic;
				delete _currentView;
			}
		}

	// End of segment: D:\Code\Planner4Life(Release)\GUI\Planner4LifeGUI.h





	/**
	 * origin: D:\Code\Planner4Life(Release)\GUI\Planner4LifeGUI.h
	 */


		/************************************************************************************************

		Initialization

		************************************************************************************************/
		//Function to initialize beginning state of Planner4Life to home screen with loadFile prompt
	private: System::Void GUI_Load(System::Object^  sender, System::EventArgs^  e) {
		string strStatus = _plannerLogic->displayStatus();

		executeHome(sender, e);
		status->Text = gcnew String(strStatus.c_str());
		missedAlertCheck();
	}

			 /************************************************************************************************

			 GUI control functions

			 ************************************************************************************************/

			 //Handler function that takes in user input and directs it to the different Planner operations
	private: System::Void userInput_Process(System::Object^  sender, System::Windows::Forms::KeyEventArgs^  e) {
		string searchCheck, clearCommand;
		String^ input = userInput->Text;

		searchCheck = msclr::interop::marshal_as<std::string>(input);

		if (e->KeyCode == Keys::Enter) {
			e->Handled = true;

			if (input == COMMAND_HOME) {
				executeHome(sender, e);
			}
			else if (input == COMMAND_MISSED) {
				executeMissed(sender, e);
			}
			else if (input == COMMAND_UPCOMING) {
				executeUpcoming(sender, e);
			}
			else if (input == COMMAND_HELP) {
				executeHelp();
			}
			else if (input == COMMAND_SHOW_DONE) {
				executeDone();
			}
			else if (input == COMMAND_ALL) {
				executeAll();
			}
			else if (input == COMMAND_EXIT) {
				executeExit();
			}
			else if (input == COMMAND_CLEAR) {
				activateCleartrigger();
			}
			else if ((input == COMMAND_Y || input == COMMAND_N || input == COMMAND_y || input == COMMAND_n) && _clearTrigger == true) {
				executeClear();
			}
			else if (searchCheck.find("search") != string::npos) {
				executeSearch();
			}
			else {
				processInput(input, _currentView);
			}

			userInput->Text = "";
		}
	}

			 // Parent function to take in all other user input, pass to Logic and return display and user prompt. All user input goes through 
			 // this function, but some specific commads (ie search, show done) require setup of UI state before processing. Their functions 
			 // are listed below
	private: System::Void processInput(String^ managedInput, String^ managedView) {
		String^ StrDisplay;
		String^ StrStatus;
		string unmanagedInput = msclr::interop::marshal_as<std::string>(managedInput);
		string unmanagedView = msclr::interop::marshal_as<std::string>(managedView);

		_plannerLogic->processUserInput(unmanagedInput, unmanagedView);
		missedAlertCheck();

		string strDisplay = _plannerLogic->displayContent();
		string strStatus = _plannerLogic->displayStatus();

		StrDisplay = gcnew String(strDisplay.c_str());
		displayWindow->Text = StrDisplay;
		StrStatus = gcnew String(strStatus.c_str());
		status->Text = StrStatus;
	}

			 //Function to execute 'help' command'
	private: System::Void executeHelp() {
		_currentView = VIEWTYPE_HELP;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 //Function to execute 'show done' command
	private: System::Void executeDone() {
		_currentView = VIEWTYPE_DONE;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 // Function to execute 'all' command
	private: System::Void executeAll() {
		_currentView = VIEWTYPE_ALL;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 //Function to execute 'exit' command
	private: System::Void executeExit() {
		Application::Exit();
	}

			 //Function to set up preliminary action for 'clear' operation - warns user and sets the UI state to allow 'clear' command
	private: System::Void activateCleartrigger() {
		status->Text = STATUS_CLEAR_PROMPT;
		_clearTrigger = true;
	}

			 //Function to execute 'clear' operation. Thereafter resets UI state to disallow immediate 'clear' on command. 
	private: System::Void executeClear() {
		_currentView = VIEWTYPE_HOME;
		switchView(_currentView);

		String^ StrDecision = "clear ";
		StrDecision = StrDecision + userInput->Text;

		processInput(StrDecision, _currentView);
		_clearTrigger = false;
	}

			 //Function to execute 'search' operation
	private: System::Void executeSearch() {
		_currentView = VIEWTYPE_SEARCH;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 /************************************************************************************************

			 GUI view functions

			 ************************************************************************************************/

			 //Function to control the colour of buttons depending on the view type. Views that are not Home, Upcoming or Missed
			 // are not specially highlighted.
	private: System::Void colourSwitch(String^ _currentView) {
		if (_currentView == VIEWTYPE_HOME) {
			homeButton->BackColor = Color::LightSkyBlue;
			missedButton->BackColor = Color::SteelBlue;
			upcomingButton->BackColor = Color::SteelBlue;
		}
		else if (_currentView == VIEWTYPE_UPCOMING) {
			upcomingButton->BackColor = Color::LightSkyBlue;
			missedButton->BackColor = Color::SteelBlue;
			homeButton->BackColor = Color::SteelBlue;
		}
		else if (_currentView == VIEWTYPE_MISSED) {
			missedButton->BackColor = Color::LightSkyBlue;
			upcomingButton->BackColor = Color::SteelBlue;
			homeButton->BackColor = Color::SteelBlue;
		}
		else {
			missedButton->BackColor = Color::SteelBlue;
			upcomingButton->BackColor = Color::SteelBlue;
			homeButton->BackColor = Color::SteelBlue;
		}
	}

			 //Function to check if there are any missed tasks. If there are, "Missed" button text becomes red to alert user
	private: System::Void missedAlertCheck(){
		bool areMissedTasks = _plannerLogic->checkMissedStatus();

		if (areMissedTasks){
			missedButton->ForeColor = Color::IndianRed;
		}
		else{
			missedButton->ForeColor = SystemColors::ControlText;
		}
	}

			 //Function to switch the view type of the GUI between Home, Upcoming and Missed.
	private: System::Void switchView(String^ viewType) {
		string unmanagedView = msclr::interop::marshal_as<std::string>(viewType);

		_plannerLogic->updateDisplay(unmanagedView);

		string strDisplay = _plannerLogic->displayContent();
		displayWindow->Text = gcnew String(strDisplay.c_str());
		colourSwitch(_currentView);
	}

			 //Function to execute view change to Home view
	private: System::Void executeHome(System::Object^  sender, System::EventArgs^  e) {
		_currentView = VIEWTYPE_HOME;
		switchView(_currentView);
		status->Text = VIEWTYPE_HOME;
	}

			 //Function to execute view change to Upcoming view
	private: System::Void executeUpcoming(System::Object^  sender, System::EventArgs^  e) {
		_currentView = VIEWTYPE_UPCOMING;
		switchView(_currentView);
		status->Text = VIEWTYPE_UPCOMING;
	}

			 //Function to execute view change to Missed view
	private: System::Void executeMissed(System::Object^  sender, System::EventArgs^  e) {
		_currentView = VIEWTYPE_MISSED;
		switchView(_currentView);
		status->Text = VIEWTYPE_MISSED;
	}
	};
}
	// End of segment: D:\Code\Planner4Life(Release)\GUI\Planner4LifeGUI.h





	/**
	 * origin: D:\Code\Planner4LifeGUI.h
	 */


	private:
		//UI operation elements
		Logic* _plannerLogic;
		String^ _currentView;
		bool _clearTrigger;

		//GUI elements
		System::Windows::Forms::TextBox^  displayWindow;
		System::Windows::Forms::TextBox^  userInput;
		System::Windows::Forms::Button^  missedButton;
		System::Windows::Forms::Button^  upcomingButton;
		System::Windows::Forms::Button^  homeButton;
		System::Windows::Forms::Label^  status;


		//constant strings
		String^ VIEWTYPE_HOME = "Home";
		String^ VIEWTYPE_UPCOMING = "Upcoming";
		String^ VIEWTYPE_MISSED = "Missed";
		String^ VIEWTYPE_HELP = "Help";
		String^ VIEWTYPE_ALL = "All";
		String^ VIEWTYPE_DONE = "Done";
		String^ VIEWTYPE_SEARCH = "Search";

		String^ COMMAND_HOME = "home";
		String^ COMMAND_UPCOMING = "upcoming";
		String^ COMMAND_MISSED = "missed";
		String^ COMMAND_HELP = "help";
		String^ COMMAND_ALL = "all";
		String^ COMMAND_SHOW_DONE = "show done";
		String^ COMMAND_SEARCH = "search";
		String^ COMMAND_EXIT = "exit";
		String^ COMMAND_CLEAR = "clear";
		String^ COMMAND_Y = "Y";
		String^ COMMAND_N = "N";
		String^ COMMAND_y = "y";
		String^ COMMAND_n = "n";
		String^ STATUS_CLEAR_PROMPT = "Are you sure you want to clear? Enter <Y> to confirm or <N> to cancel";

		/// Required designer variable.
		System::ComponentModel::Container ^components;

	public:
		GUI(void){
			InitializeComponent();
			//Add the constructor code here
			_plannerLogic = new Logic;
			_currentView = VIEWTYPE_HOME;
			_clearTrigger = false;
		}

	protected:
		/// Clean up any resources being used.
		~GUI(){
			if (components)	{
				delete components;
				delete _plannerLogic;
				delete _currentView;
			}
		}

	// End of segment: D:\Code\Planner4LifeGUI.h





	/**
	 * origin: D:\Code\Planner4LifeGUI.h
	 */


		/************************************************************************************************

		Initialization

		************************************************************************************************/
		//Function to initialize beginning state of Planner4Life to home screen with loadFile prompt
	private: System::Void GUI_Load(System::Object^  sender, System::EventArgs^  e) {
		string strStatus = _plannerLogic->displayStatus();

		executeHome(sender, e);
		status->Text = gcnew String(strStatus.c_str());
		missedAlertCheck();
	}

			 /************************************************************************************************

			 GUI control functions

			 ************************************************************************************************/

			 //Handler function that takes in user input and directs it to the different Planner operations
	private: System::Void userInput_Process(System::Object^  sender, System::Windows::Forms::KeyEventArgs^  e) {
		string searchCheck, clearCommand;
		String^ input = userInput->Text;

		searchCheck = msclr::interop::marshal_as<std::string>(input);

		if (e->KeyCode == Keys::Enter) {
			e->Handled = true;

			if (input == COMMAND_HOME) {
				executeHome(sender, e);
			}
			else if (input == COMMAND_MISSED) {
				executeMissed(sender, e);
			}
			else if (input == COMMAND_UPCOMING) {
				executeUpcoming(sender, e);
			}
			else if (input == COMMAND_HELP) {
				executeHelp();
			}
			else if (input == COMMAND_SHOW_DONE) {
				executeDone();
			}
			else if (input == COMMAND_ALL) {
				executeAll();
			}
			else if (input == COMMAND_EXIT) {
				executeExit();
			}
			else if (input == COMMAND_CLEAR) {
				activateCleartrigger();
			}
			else if ((input == COMMAND_Y || input == COMMAND_N || input == COMMAND_y || input == COMMAND_n) && _clearTrigger == true) {
				executeClear();
			}
			else if (searchCheck.find("search") != string::npos) {
				executeSearch();
			}
			else {
				processInput(input, _currentView);
			}

			userInput->Text = "";
		}
	}

			 // Parent function to take in all other user input, pass to Logic and return display and user prompt. All user input goes through 
			 // this function, but some specific commads (ie search, show done) require setup of UI state before processing. Their functions 
			 // are listed below
	private: System::Void processInput(String^ managedInput, String^ managedView) {
		String^ StrDisplay;
		String^ StrStatus;
		string unmanagedInput = msclr::interop::marshal_as<std::string>(managedInput);
		string unmanagedView = msclr::interop::marshal_as<std::string>(managedView);

		_plannerLogic->processUserInput(unmanagedInput, unmanagedView);
		missedAlertCheck();

		string strDisplay = _plannerLogic->displayContent();
		string strStatus = _plannerLogic->displayStatus();

		StrDisplay = gcnew String(strDisplay.c_str());
		displayWindow->Text = StrDisplay;
		StrStatus = gcnew String(strStatus.c_str());
		status->Text = StrStatus;
	}

			 //Function to execute 'help' command'
	private: System::Void executeHelp() {
		_currentView = VIEWTYPE_HELP;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 //Function to execute 'show done' command
	private: System::Void executeDone() {
		_currentView = VIEWTYPE_DONE;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 // Function to execute 'all' command
	private: System::Void executeAll() {
		_currentView = VIEWTYPE_ALL;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 //Function to execute 'exit' command
	private: System::Void executeExit() {
		Application::Exit();
	}

			 //Function to set up preliminary action for 'clear' operation - warns user and sets the UI state to allow 'clear' command
	private: System::Void activateCleartrigger() {
		status->Text = STATUS_CLEAR_PROMPT;
		_clearTrigger = true;
	}

			 //Function to execute 'clear' operation. Thereafter resets UI state to disallow immediate 'clear' on command. 
	private: System::Void executeClear() {
		_currentView = VIEWTYPE_HOME;
		switchView(_currentView);

		String^ StrDecision = "clear ";
		StrDecision = StrDecision + userInput->Text;

		processInput(StrDecision, _currentView);
		_clearTrigger = false;
	}

			 //Function to execute 'search' operation
	private: System::Void executeSearch() {
		_currentView = VIEWTYPE_SEARCH;
		processInput(userInput->Text, _currentView);
		colourSwitch(_currentView);
	}

			 /************************************************************************************************

			 GUI view functions

			 ************************************************************************************************/

			 //Function to control the colour of buttons depending on the view type. Views that are not Home, Upcoming or Missed
			 // are not specially highlighted.
	private: System::Void colourSwitch(String^ _currentView) {
		if (_currentView == VIEWTYPE_HOME) {
			homeButton->BackColor = Color::LightSkyBlue;
			missedButton->BackColor = Color::SteelBlue;
			upcomingButton->BackColor = Color::SteelBlue;
		}
		else if (_currentView == VIEWTYPE_UPCOMING) {
			upcomingButton->BackColor = Color::LightSkyBlue;
			missedButton->BackColor = Color::SteelBlue;
			homeButton->BackColor = Color::SteelBlue;
		}
		else if (_currentView == VIEWTYPE_MISSED) {
			missedButton->BackColor = Color::LightSkyBlue;
			upcomingButton->BackColor = Color::SteelBlue;
			homeButton->BackColor = Color::SteelBlue;
		}
		else {
			missedButton->BackColor = Color::SteelBlue;
			upcomingButton->BackColor = Color::SteelBlue;
			homeButton->BackColor = Color::SteelBlue;
		}
	}

			 //Function to check if there are any missed tasks. If there are, "Missed" button text becomes red to alert user
	private: System::Void missedAlertCheck(){
		bool areMissedTasks = _plannerLogic->checkMissedStatus();

		if (areMissedTasks){
			missedButton->ForeColor = Color::IndianRed;
		}
		else{
			missedButton->ForeColor = SystemColors::ControlText;
		}
	}

			 //Function to switch the view type of the GUI between Home, Upcoming and Missed.
	private: System::Void switchView(String^ viewType) {
		string unmanagedView = msclr::interop::marshal_as<std::string>(viewType);

		_plannerLogic->updateDisplay(unmanagedView);

		string strDisplay = _plannerLogic->displayContent();
		displayWindow->Text = gcnew String(strDisplay.c_str());
		colourSwitch(_currentView);
	}

			 //Function to execute view change to Home view
	private: System::Void executeHome(System::Object^  sender, System::EventArgs^  e) {
		_currentView = VIEWTYPE_HOME;
		switchView(_currentView);
		status->Text = VIEWTYPE_HOME;
	}

			 //Function to execute view change to Upcoming view
	private: System::Void executeUpcoming(System::Object^  sender, System::EventArgs^  e) {
		_currentView = VIEWTYPE_UPCOMING;
		switchView(_currentView);
		status->Text = VIEWTYPE_UPCOMING;
	}

			 //Function to execute view change to Missed view
	private: System::Void executeMissed(System::Object^  sender, System::EventArgs^  e) {
		_currentView = VIEWTYPE_MISSED;
		switchView(_currentView);
		status->Text = VIEWTYPE_MISSED;
	}
	};
}
	// End of segment: D:\Code\Planner4LifeGUI.h





